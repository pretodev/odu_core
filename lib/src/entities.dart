import 'package:odu_core/src/failure.dart';
import 'package:uuid/uuid.dart';

/// Base class for domain entities with generic identity.
///
/// In DDD, entities are defined by their identity (ID), not their attributes.
/// Two entities with the same ID are considered equal, regardless of their
/// current state.
///
/// Use [UuidEntity] for entities identified by UUID strings, or [SerialEntity]
/// for entities with auto-incremented integer IDs.
abstract class Entity<TId> {
  final TId id;
  final DateTime createdAt;
  final DateTime updatedAt;
  final bool isActive;

  Entity({
    required this.id,
    required this.createdAt,
    required this.updatedAt,
    this.isActive = true,
  }) {
    validate();
  }

  /// Properties specific to this entity for debugging purposes.
  ///
  /// Override this getter in subclasses to include domain-specific
  /// properties in [toString] output. These are NOT used for equality.
  List<Object?> get props => [];

  /// Validates the entity's invariants.
  ///
  /// Override this method to enforce business rules. This is called
  /// automatically during construction.
  ///
  /// Throws [EntityFailure] if validation fails.
  void validate() {}

  /// Whether this entity has been modified since creation.
  bool get hasChanged => updatedAt.isAfter(createdAt);

  /// Whether this entity has been deactivated (soft deleted).
  bool get isDeleted => !isActive;

  /// Entities are equal if they have the same ID and runtime type.
  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Entity<TId> &&
            runtimeType == other.runtimeType &&
            id == other.id);
  }

  @override
  int get hashCode => runtimeType.hashCode ^ id.hashCode;

  @override
  String toString() {
    final allProps = ['id: $id', 'active: $isActive', ...props];
    return '$runtimeType(${allProps.join(', ')})';
  }
}

/// Entity identified by a UUID string.
///
/// Use this for entities where IDs are generated client-side.
///
/// Example:
/// ```dart
/// class User extends UuidEntity {
///   final String email;
///
///   User._({
///     required super.id,
///     required super.createdAt,
///     required super.updatedAt,
///     required super.isActive,
///     required this.email,
///   });
///
///   factory User.create({required String email}) {
///     final now = DateTime.now();
///     return User._(
///       id: const Uuid().v4(),
///       createdAt: now,
///       updatedAt: now,
///       isActive: true,
///       email: email,
///     );
///   }
///
///   User copyWith({String? email, bool? isActive, DateTime? updatedAt}) {
///     return User._(
///       id: id,
///       createdAt: createdAt,
///       updatedAt: updatedAt ?? DateTime.now(),
///       isActive: isActive ?? this.isActive,
///       email: email ?? this.email,
///     );
///   }
/// }
/// ```
abstract class GuidEntity extends Entity<String> {
  GuidEntity({
    required super.id,
    required super.createdAt,
    required super.updatedAt,
    super.isActive,
  });

  /// Generates a new UUID v4.
  static String newId() => const Uuid().v4();
}

/// Entity identified by an auto-incremented integer ID.
///
/// Use this for entities where IDs are generated by the database.
/// New (unpersisted) entities should use [SerialEntity.unsavedId] as their ID.
///
/// Example:
/// ```dart
/// class Product extends SerialEntity {
///   final String name;
///
///   Product._({
///     required super.id,
///     required super.createdAt,
///     required super.updatedAt,
///     required super.isActive,
///     required this.name,
///   });
///
///   /// Creates a new unpersisted product.
///   factory Product.create({required String name}) {
///     final now = DateTime.now();
///     return Product._(
///       id: SerialEntity.unsavedId,
///       createdAt: now,
///       updatedAt: now,
///       isActive: true,
///       name: name,
///     );
///   }
///
///   /// Reconstitutes a product from persistence.
///   factory Product.fromPersistence({
///     required int id,
///     required DateTime createdAt,
///     required DateTime updatedAt,
///     required bool isActive,
///     required String name,
///   }) {
///     return Product._(
///       id: id,
///       createdAt: createdAt,
///       updatedAt: updatedAt,
///       isActive: isActive,
///       name: name,
///     );
///   }
///
///   Product copyWith({String? name, bool? isActive, DateTime? updatedAt}) {
///     return Product._(
///       id: id,
///       createdAt: createdAt,
///       updatedAt: updatedAt ?? DateTime.now(),
///       isActive: isActive ?? this.isActive,
///       name: name ?? this.name,
///     );
///   }
/// }
/// ```
abstract class SerialEntity extends Entity<int> {
  /// ID value for entities not yet persisted to database.
  static const int unsavedId = 0;

  SerialEntity({
    required super.id,
    required super.createdAt,
    required super.updatedAt,
    super.isActive,
  });

  /// Whether this entity has been persisted (has a valid database ID).
  bool get isPersisted => id != unsavedId;

  /// Whether this entity is new and hasn't been saved yet.
  bool get isNew => id == unsavedId;
}

/// Base class for entity-related failures.
abstract class EntityFailure extends Failure {
  EntityFailure(super.message);
}
